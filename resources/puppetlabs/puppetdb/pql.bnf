query = expression;

(* TODO: order by *)
(* TODO: limit, offset *)
(* TODO: include_total *)
(* TODO: group_by *)
(* TODO: from *)
(* TODO: extract - projection *)
(* TODO: subqueries *)
(* TODO: aggregate functions *)

(* Expressions - the number after expr is the order of precedence *)
expression = expr4;
expr4      = expr3 { [<whitespace>], or, [<whitespace>], expr4 };
expr3      = expr2 { [<whitespace>], and, [<whitespace>], expr3 };
expr2      = {[ not ] expr2 } | expr1;
expr1      = { lbracket, expression, rbracket } | condexpression;

(* Conditional expression *)
(* TODO: '~>' and 'null?' and 'in' *)
condexpression   = field, [<whitespace>], (condexpregexp | condexpnumber | condexpmatch);
<condexpregexp> = condregexp, [<whitespace>], valueregexp;
<condexpnumber>  = condnumber, [<whitespace>], valuenumber;
<condexpmatch>   = condmatch, [<whitespace>], valuematch;

(* Conditional expression parts *)
field       = #'[a-zA-Z_]+';
condregexp  = '!~' | '=~';
condnumber  = '>=' | '<=' | '<' | '>';
condmatch   = '==' | '!=';
valueregexp = regexp;
valuenumber = integer | real;
valuematch  = string | integer | real | boolean;

(* Boolean operators *)
(* TODO: do we want case insensivity here for 'and', 'or', and 'not' *)
and = [<whitespace>], <'and'>, [<whitespace>];
or  = [<whitespace>], <'or'>, [<whitespace>];
not = [<whitespace>], <'!'>, [<whitespace>]; (* TODO: determine if we want 'not' here also *)

(* Regexp strings *)
(* TODO: regexp should accept almost anything but a bare /, we should test regexp with / in it, to ensure it fails *)
regexp = <regexpquote>, stringcomponent, <regexpquote>
<regexpquote> = "/"

(* Value strings *)
(* TODO: strings should accept almost anything but a bare quote, we should test valuestring with ' or " in it, ensure it fails  *)
string = (<singlequote>, stringcomponent, <singlequote>) | (<doublequote>, stringcomponent, <doublequote>);
<stringcomponent> = #'[a-zA-Z_]+';

(* Quotes *)
<singlequote> = "'";
<doublequote> = "\"";

(* Grouping *)
<lbracket> = [<whitespace>], '(', [<whitespace>];
<rbracket> = [<whitespace>], ')', [<whitespace>];

(* Booleans *)
boolean = true | false;
true = <"true">;
false = <"false">;

(* Numbers *)
integer    = [negative], digits;
real       = [negative], digits, ".", digits, [exp];
exp        = <"E" | "e">, [negative], digits;
<digits>   = #"[0-9]+";
<negative> = "-";

(* Whitespace *)
<whitespace> = #'\s+';

